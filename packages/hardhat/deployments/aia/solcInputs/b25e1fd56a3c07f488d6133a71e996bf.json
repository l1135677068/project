{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"./IERC20.sol\";\nimport { IERC20Metadata } from \"./extensions/IERC20Metadata.sol\";\nimport { Context } from \"../../utils/Context.sol\";\nimport { IERC20Errors } from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n\tmapping(address account => uint256) private _balances;\n\n\tmapping(address account => mapping(address spender => uint256))\n\t\tprivate _allowances;\n\n\tuint256 private _totalSupply;\n\n\tstring private _name;\n\tstring private _symbol;\n\n\t/**\n\t * @dev Sets the values for {name} and {symbol}.\n\t *\n\t * All two of these values are immutable: they can only be set once during\n\t * construction.\n\t */\n\tconstructor(string memory name_, string memory symbol_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t}\n\n\t/**\n\t * @dev Returns the name of the token.\n\t */\n\tfunction name() public view virtual returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev Returns the symbol of the token, usually a shorter version of the\n\t * name.\n\t */\n\tfunction symbol() public view virtual returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n\t *\n\t * Tokens usually opt for a value of 18, imitating the relationship between\n\t * Ether and Wei. This is the default value returned by this function, unless\n\t * it's overridden.\n\t *\n\t * NOTE: This information is only used for _display_ purposes: it in\n\t * no way affects any of the arithmetic of the contract, including\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\n\t */\n\tfunction decimals() public view virtual returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {IERC20-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {IERC20-balanceOf}.\n\t */\n\tfunction balanceOf(address account) public view virtual returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t * - the caller must have a balance of at least `value`.\n\t */\n\tfunction transfer(address to, uint256 value) public virtual returns (bool) {\n\t\taddress owner = _msgSender();\n\t\t_transfer(owner, to, value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-allowance}.\n\t */\n\tfunction allowance(\n\t\taddress owner,\n\t\taddress spender\n\t) public view virtual returns (uint256) {\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev See {IERC20-approve}.\n\t *\n\t * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n\t * `transferFrom`. This is semantically equivalent to an infinite approval.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction approve(\n\t\taddress spender,\n\t\tuint256 value\n\t) public virtual returns (bool) {\n\t\taddress owner = _msgSender();\n\t\t_approve(owner, spender, value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP. See the note at the beginning of {ERC20}.\n\t *\n\t * NOTE: Does not update the allowance if the current allowance\n\t * is the maximum `uint256`.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` and `to` cannot be the zero address.\n\t * - `from` must have a balance of at least `value`.\n\t * - the caller must have allowance for ``from``'s tokens of at least\n\t * `value`.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) public virtual returns (bool) {\n\t\taddress spender = _msgSender();\n\t\t_spendAllowance(from, spender, value);\n\t\t_transfer(from, to, value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves a `value` amount of tokens from `from` to `to`.\n\t *\n\t * This internal function is equivalent to {transfer}, and can be used to\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * NOTE: This function is not virtual, {_update} should be overridden instead.\n\t */\n\tfunction _transfer(address from, address to, uint256 value) internal {\n\t\tif (from == address(0)) {\n\t\t\trevert ERC20InvalidSender(address(0));\n\t\t}\n\t\tif (to == address(0)) {\n\t\t\trevert ERC20InvalidReceiver(address(0));\n\t\t}\n\t\t_update(from, to, value);\n\t}\n\n\t/**\n\t * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n\t * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n\t * this function.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _update(address from, address to, uint256 value) internal virtual {\n\t\tif (from == address(0)) {\n\t\t\t// Overflow check required: The rest of the code assumes that totalSupply never overflows\n\t\t\t_totalSupply += value;\n\t\t} else {\n\t\t\tuint256 fromBalance = _balances[from];\n\t\t\tif (fromBalance < value) {\n\t\t\t\trevert ERC20InsufficientBalance(from, fromBalance, value);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\t// Overflow not possible: value <= fromBalance <= totalSupply.\n\t\t\t\t_balances[from] = fromBalance - value;\n\t\t\t}\n\t\t}\n\n\t\tif (to == address(0)) {\n\t\t\tunchecked {\n\t\t\t\t// Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n\t\t\t\t_totalSupply -= value;\n\t\t\t}\n\t\t} else {\n\t\t\tunchecked {\n\t\t\t\t// Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n\t\t\t\t_balances[to] += value;\n\t\t\t}\n\t\t}\n\n\t\temit Transfer(from, to, value);\n\t}\n\n\t/**\n\t * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n\t * Relies on the `_update` mechanism\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * NOTE: This function is not virtual, {_update} should be overridden instead.\n\t */\n\tfunction _mint(address account, uint256 value) internal {\n\t\tif (account == address(0)) {\n\t\t\trevert ERC20InvalidReceiver(address(0));\n\t\t}\n\t\t_update(address(0), account, value);\n\t}\n\n\t/**\n\t * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n\t * Relies on the `_update` mechanism.\n\t *\n\t * Emits a {Transfer} event with `to` set to the zero address.\n\t *\n\t * NOTE: This function is not virtual, {_update} should be overridden instead\n\t */\n\tfunction _burn(address account, uint256 value) internal {\n\t\tif (account == address(0)) {\n\t\t\trevert ERC20InvalidSender(address(0));\n\t\t}\n\t\t_update(account, address(0), value);\n\t}\n\n\t/**\n\t * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n\t *\n\t * This internal function is equivalent to `approve`, and can be used to\n\t * e.g. set automatic allowances for certain subsystems, etc.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t *\n\t * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n\t */\n\tfunction _approve(address owner, address spender, uint256 value) internal {\n\t\t_approve(owner, spender, value, true);\n\t}\n\n\t/**\n\t * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n\t *\n\t * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n\t * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n\t * `Approval` event during `transferFrom` operations.\n\t *\n\t * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n\t * true using the following override:\n\t * ```\n\t * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n\t *     super._approve(owner, spender, value, true);\n\t * }\n\t * ```\n\t *\n\t * Requirements are the same as {_approve}.\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tbool emitEvent\n\t) internal virtual {\n\t\tif (owner == address(0)) {\n\t\t\trevert ERC20InvalidApprover(address(0));\n\t\t}\n\t\tif (spender == address(0)) {\n\t\t\trevert ERC20InvalidSpender(address(0));\n\t\t}\n\t\t_allowances[owner][spender] = value;\n\t\tif (emitEvent) {\n\t\t\temit Approval(owner, spender, value);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n\t *\n\t * Does not update the allowance value in case of infinite allowance.\n\t * Revert if not enough allowance is available.\n\t *\n\t * Does not emit an {Approval} event.\n\t */\n\tfunction _spendAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value\n\t) internal virtual {\n\t\tuint256 currentAllowance = allowance(owner, spender);\n\t\tif (currentAllowance != type(uint256).max) {\n\t\t\tif (currentAllowance < value) {\n\t\t\t\trevert ERC20InsufficientAllowance(\n\t\t\t\t\tspender,\n\t\t\t\t\tcurrentAllowance,\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\t_approve(owner, spender, currentAllowance - value, false);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value\n\t);\n\n\t/**\n\t * @dev Returns the value of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the value of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(\n\t\taddress owner,\n\t\taddress spender\n\t) external view returns (uint256);\n\n\t/**\n\t * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n\t * caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @dev Moves a `value` amount of tokens from `from` to `to` using the\n\t * allowance mechanism. `value` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/Dex.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Dex is ERC20 {\n\taddress owner;\n\tIERC20 token0;\n\tIERC20 token1;\n\n\t// 代币储备量\n\tuint256 public reserve0;\n\tuint256 public reserve1;\n\n\tevent Burn(\n\t\tuint256 tokenZeroAmount,\n\t\tuint256 tokenOneAmount,\n\t\tuint256 lpAmount,\n\t\taddress provider\n\t);\n\n\tevent Mint(\n\t\tuint256 tokenZeroAmount,\n\t\tuint256 tokenOneAmount,\n\t\tuint256 lpAmount,\n\t\taddress provider\n\t);\n\n\tevent Swap(\n\t\taddress sender,\n\t\tuint256 amountIn,\n\t\tIERC20 tokenIn,\n\t\tuint256 amountOut,\n\t\tIERC20 tokenOut\n\t);\n\n\t// 构造器，初始化支持交易的代币地址\n\tconstructor(IERC20 _token0, IERC20 _token1) ERC20(\"Dex\", \"Dex\") {\n\t\ttoken0 = _token0;\n\t\ttoken1 = _token1;\n\t}\n\n\t// 取两个数的最小值\n\tfunction min(uint x, uint y) internal pure returns (uint z) {\n\t\tz = x < y ? x : y;\n\t}\n\n\t// 计算平方根\n\tfunction sqrt(uint y) internal pure returns (uint z) {\n\t\tif (y > 3) {\n\t\t\tz = y;\n\t\t\tuint x = y / 2 + 1;\n\t\t\twhile (x < z) {\n\t\t\t\tz = x;\n\t\t\t\tx = (y / x + x) / 2;\n\t\t\t}\n\t\t} else if (y != 0) {\n\t\t\tz = 1;\n\t\t}\n\t}\n\n\t// 添加流动性\n\tfunction addLiquidity(\n\t\tuint256 amount0,\n\t\tuint256 amount1\n\t) public returns (uint256 lpAmount) {\n\t\t// 委托\n\t\ttoken0.transferFrom(msg.sender, address(this), amount0);\n\t\ttoken1.transferFrom(msg.sender, address(this), amount1);\n\n\t\t// 流动性份额\n\t\tlpAmount = 0;\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) {\n\t\t\tlpAmount = (amount0 * amount1);\n\t\t} else {\n\t\t\tlpAmount =\n\t\t\t\t_totalSupply *\n\t\t\t\tmin(amount0 / reserve0, amount1 / reserve1);\n\t\t}\n\n\t\t// 检查流动性是否大于0\n\t\trequire(lpAmount > 0, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n\t\t// 为什么不是相加？\n\t\treserve0 = token0.balanceOf(address(this));\n\t\treserve1 = token1.balanceOf(address(this));\n\n\t\t//  铸造LP代币\n\t\t_mint(msg.sender, lpAmount);\n\t\temit Mint(amount0, amount1, lpAmount, msg.sender);\n\t}\n\n\t// 移除流动性\n\tfunction removeLiquidity(\n\t\tuint256 lpAmount\n\t) public returns (uint256 amount0, uint256 amount1) {\n\t\t// 获取余额\n\t\tuint256 balance0 = token0.balanceOf(address(this));\n\t\tuint256 balance1 = token1.balanceOf(address(this));\n\n\t\t// 要转出的代币数量\n\t\tuint256 totalLp = totalSupply();\n\t\tamount0 = (balance0 * lpAmount) / totalLp;\n\t\tamount1 = (balance1 * lpAmount) / totalLp;\n\n\t\t// 检查代币数量\n\t\trequire(amount0 > 0 && amount1 > 0, \"INSUFFICIENT_LIQUIDITY_BURNED\");\n\n\t\t// 销毁Lp\n\t\t_burn(msg.sender, lpAmount);\n\t\t// 转移代币\n\t\ttoken0.transfer(msg.sender, amount0);\n\t\ttoken1.transfer(msg.sender, amount1);\n\n\t\temit Burn(amount0, amount1, lpAmount, msg.sender);\n\t}\n\n\t// 交易数量\n\tfunction getSwapAmountOut(\n\t\tuint256 amountIn,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) public pure returns (uint256 amountOut) {\n\t\trequire(amountIn > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"INSUFFICIENT_LIQUIDITY\");\n\t\tamountOut = (amountIn * reserveOut) / (reserveIn + amountIn);\n\t\treturn amountOut;\n\t}\n\n\t// 交易\n\tfunction swap(\n\t\tuint256 amountIn,\n\t\tIERC20 tokenIn,\n\t\tuint256 minAmountOut\n\t) public returns (uint amountOut, IERC20 tokenOut) {\n\t\trequire(amountIn > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\t\trequire(tokenIn == token0 || tokenIn == token1, \"INVALID_TOKEN\");\n\n\t\t// 代币余额\n\t\tuint256 balance0 = token0.balanceOf(address(this));\n\t\tuint256 balance1 = token1.balanceOf(address(this));\n\t\t// token0 交换token1\n\t\tif (tokenIn == token0) {\n\t\t\ttokenOut = token1;\n\t\t\tamountOut = getSwapAmountOut(amountIn, balance0, balance1);\n\t\t} else {\n\t\t\t// token1 交换token0\n\t\t\ttokenOut = token0;\n\t\t\tamountOut = getSwapAmountOut(amountIn, balance1, balance0);\n\t\t}\n\n\t\trequire(amountOut > minAmountOut, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\t// 转移代币\n\t\ttokenIn.transferFrom(msg.sender, address(this), amountIn);\n\t\ttokenOut.transfer(msg.sender, amountOut);\n\t\t// 更新储备量\n\t\treserve0 = token0.balanceOf(address(this));\n\t\treserve1 = token1.balanceOf(address(this));\n\n\t\temit Swap(msg.sender, amountIn, tokenIn, amountOut, tokenOut);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}